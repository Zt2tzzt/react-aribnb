# Header 动画效果的实现。

在 Header 中新增 content 和 cover 区域。

content 中新增 top 和 search-area 区域。

src\components\app-header\AppHeader.jsx

```jsx
<ThemeProvider theme={{ isAlpha }}>
	<HeaderWrapper className={classNames({ fixed: isFixed })}>
		<div className="content">
			<div className="top">
				<Left />
				<Center isSearch={ isAlpha || isSearch } searchBarClick={e => setIsSearch(true)} />
				<Right />
			</div>
			<SearchAreaWrapper isSearch={ isAlpha || isSearch } />
		</div>
		{isSearch && <div className='cover' onClick={e => setIsSearch(false)}></div>}
	</HeaderWrapper>
</ThemeProvider>
```

在 Center 中新增 search-bar 和 search-detail 区域。

点击 search-bar 区域，在下方展示 search-detail 区域。并添加动画效果。

src\components\app-header\cpns\center\Center.jsx

```jsx
<CenterWrapper>
	<CSSTransition
		in={!isSearch}
		classNames='bar'
		timeout={250}
		unmountOnExit={true}
	>
		<div className="search-bar" onClick={onSearchBtnClick}>
			<div className="text">搜索房源和体验</div>
			<div className="icon">
				<IconSearchBar />
			</div>
		</div>
	</CSSTransition>
	<CSSTransition
		in={isSearch}
		classNames='detail'
		timeout={250}
		unmountOnExit={true}
	>
		<div className="search-detail">
			<SearchTabs titles={titles} tabClick={setTabIndex} />
			<div className="infos">
				<SearchSection searchInfos={searchTitles[tabIndex].searchInfos} />
			</div>
		</div>
	</CSSTransition>
</CenterWrapper>
```


# 当页面滚动时，回到 search-bar 的状态。

封装一个 hook，`useScrollPosition`，用来获取页面滚动距离。

页面滚动时，造成 setScroolY 函数频繁执行，意味着 App 函数组件也被频繁的调用（组件不会频繁渲染，因为有 diff 算法）；为这个 Hook，添加节流的功能。

src\hooks\useScrollPosition.js

```js
import { useEffect, useState } from "react";
import throttle from '@/utils/throttle'

export default function useScrollPosition() {
	const [scrollX, setScrollX] = useState(0);
	const [scrollY, setScrollY] = useState(0);

	useEffect(() => {
		const handleScroll = throttle(() => {
			setScrollX(window.scrollX)
			setScrollY(window.scrollY)
		}, 100, { trailing: true })

		window.addEventListener('scroll', handleScroll)
		return () => {
			window.removeEventListener('scroll', handleScroll)
		}
	}, [])

	return { scrollX, scrollY }
}
```

使用 `useRef` 对页面滚动的位置做记录。

src\components\app-header\AppHeader.jsx

```js
const { scrollY } = useScrollPosition()
const prevY = useRef(0) // 记录滚动的位置

if (!isSearch) prevY.current = scrollY
```

> 一般不影响页面刷新的值，都不用 state 进行管理。一般用 ref 进行管理。

# Header 回到顶部，变为透明，并展示 search-detail。

在 main store 中维护一个是否透明的状态。

```json
initialState: {
	headerConfig: {
		isFixed: false,
		topAlpha: false
	}
},
```

为了控制整个 Header 区域中的样式，使用 ThemeProvider 来提供 isAlpha 的状态。

src\components\app-header\AppHeader.jsx

```jsx
const { headerConfig } = useSelector(
	state => ({
		headerConfig: state.main.headerConfig
	}),
	shallowEqual
)
//...
const { topAlpha } = headerConfig
//...
const isAlpha = topAlpha && scrollY === 0
//...
<ThemeProvider theme={{ isAlpha }}>
{/* ... */}
</ThemeProvider>
```

# Header 回到顶部，展示 search-detail。	

使用 isAlpha 和 isSearch 共同控制 search-detail 的展示。

src\components\app-header\AppHeader.jsx

```jsx
<Center isSearch={ isAlpha || isSearch } searchBarClick={e => setIsSearch(true)} />
```

src\components\app-header\cpns\center\Center.jsx

```jsx
<CSSTransition
	in={isSearch}
	classNames='detail'
	timeout={250}
	unmountOnExit={true}
>
	<div className="search-detail">
		<SearchTabs titles={titles} tabClick={setTabIndex} />
		<div className="infos">
			<SearchSection searchInfos={searchTitles[tabIndex].searchInfos} />
		</div>
	</div>
</CSSTransition>
```

展示 search-detail 时，使用 fixed 布局。

# 回顾项目打包发布的过程。

安装最新的 Jekins，需要安装最新的 Java，即 Java17.

访问一个 ip 地址，默认访问的是 80 端口。

